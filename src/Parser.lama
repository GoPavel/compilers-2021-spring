-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;
import Ref;
import Collection;

-- Signals an error; takes an error message and location info
fun error (msg, loc) {
  failure ("%s at %d:%d\n", msg, loc.fst, loc.snd)
}

-- An attribute-processing functions
-- Attributes are:
--   Val  --- a plain value (aka "rvalue")
--   Ref  --- a reference to a mutable cell (aka "lvalue")
--   Void --- no value (aka "void"/"unit")

-- Checks if a plain value "val" can be used in the context described by
-- the attribute "atr".
fun assertValue (atr, v, loc) {
  case atr of
    Ref  -> error ("reference expected", loc)
  | Void -> Ignore (v)
  | _    -> v
  esac
}

fun assertVoid (atr, v, loc) {
  case atr of
    Void -> v
  | Val  -> error ("value expected", loc)
  | _    -> error ("reference expected", loc)
  esac
}

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun binop (op) {
  [syntax (pos -s[op]), fun (l, loc, r) {
                          fun (a) {
                            assertValue (a, Binop (op, l (Val), r (Val)), loc)
                          }
                        }
  ]
}

var primary  = memo $ eta syntax (
                                  -- decimal constant
                                  loc=pos x=decimal                                 {fun (a) {assertValue (a, Const (stringInt (x)), loc)}}     |

                                  -- identifier
                                  x=lident                                          {fun (a) {
                                                                                       case a of
                                                                                         Ref  -> Ref (x)
                                                                                       | Void -> Ignore (Var (x))
                                                                                       | _    -> Var (x)
                                                                                       esac
                                                                                    }} |
                                  $(failure ("the rest of primary parsing in not implemented\n"))),
    basic    = memo $ eta (expr ({[Right, {[s (":="),
                                            fun (l, loc, r) {
                                              fun (a) {assertValue (a, Assn (l (Ref), r (Val)), loc)}
                                            }]}],
                                  [Left , map (binop, {"!!"})],
                                  [Left , map (binop, {"&&"})],
                                  [Nona , map (binop, {"==", "!=", "<", ">", "<=", ">="})],
                                  [Left , map (binop, {"+", "-"})],
                                  [Left , map (binop, {"*", "/", "%"})]
                                 },
                                 primary)),
    exp      = memo $ eta syntax (basic | s1=basic s[";"] s2=exp {fun (a) {Seq (s1 (Void), s2 (a))}});

-- Public top-level parser
public parse = syntax (s=exp {s (Void)});

-- infix <| after |> (a, b) { syntax (a -b) } 

-- -- eta :: (a -> x) -> (a -> x)

-- var bl = s ("("), br = s (")");

-- -- Primary expression
-- var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
--                                  x=lident  {Var (x)}               |
--                                  inbr[bl, exp, br]),
--     op = fun (ss) {
--       [s (ss), fun (l, _, r) {Binop (ss, l, r)}]
--     },

--     ops = { [Left, {op("!!")}]
--           , [Left, {op("&&")}]
--           , [Nona, {op("=="), op("!="), op("<="), op("<"), op(">="), op(">")}]
--           , [Left, {op("+"), op("-")}]
--           , [Left, {op("*"), op("/"), op("%")}]
--           },
--     exp = memo $ expr (ops, primary);

--     -- exp0 = memo $ eta syntax (a=exp op=$(s ("+")) b=exp {Binop (op, a, b)} | primary),
--     -- exp = exp0;

-- fun orSkip (op) {
--   case op of
--     None -> Skip
--   | Some (x) -> x
--   esac
-- }

-- var ifStmt = memo $ eta syntax (
--   -kIf e=exp -kThen s=stmt rest=elsePart? -kFi {If (e, s, orSkip (rest))}
-- );

-- var elsePart = memo $ eta syntax (
--     -kElif e=exp -kThen s=stmt rest=elsePart? {If (e, s, orSkip (rest))}
--   | -kElse stmt
-- );

-- var loopStmt = memo $ eta syntax (
--     -kWhile e=exp -kDo s=stmt -kOd {While (e, s)}
--   | -kDo s=stmt -kWhile e=exp -kOd {DoWhile (s, e)}
--   | -kFor init=stmt -$(s (",")) cond=exp -$(s (",")) inc=stmt 
--     -kDo body=stmt -kOd
--     { Seq (init, While (cond, Seq (body, inc))) }
-- );

-- var oneStmt = memo $ eta syntax (
--     name=lident -$(s (":=")) e=exp {Assn (name, e)}
--   | -kSkip {Skip}
--   | -kWrite -bl e=exp -br {Write (e)}
--   | -kRead -bl name=lident -br {Read (name)}
--   | empty {Skip}
--   -- | controlFlow
--   | ifStmt
--   | loopStmt
-- );

-- var stmt = memo $ eta syntax (
--     x=oneStmt -$(s (";")) xs=stmt {Seq (x, xs)}
--   | oneStmt
-- );

-- -- Public top-level parser
-- public parse = memo $ eta syntax (stmt -end);

-- >>>>>>> 2ecfe09... [A01-A05] complete tasks
